"""
============================================================
CARTEIRINHA DIGITAL - Implementa√ß√£o Completa
============================================================

Adicione este c√≥digo ao seu app.py

============================================================
"""

import secrets
from datetime import datetime, timedelta

# ============================================================
# PASSO 1: Fun√ß√£o para criar a tabela de tokens
# ============================================================
# Adicione esta fun√ß√£o no app.py e chame no bloco if __name__ == '__main__':

def create_verification_tokens_table():
    """Cria a tabela para armazenar tokens de verifica√ß√£o da carteirinha"""
    conn = get_db_connection()
    
    conn.execute('''
        CREATE TABLE IF NOT EXISTS verification_tokens (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            player_id INTEGER NOT NULL,
            token TEXT NOT NULL UNIQUE,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            expires_at DATETIME NOT NULL,
            used_at DATETIME,
            used_by_business TEXT,
            FOREIGN KEY (player_id) REFERENCES players(id)
        )
    ''')
    
    # Criar √≠ndice para buscas r√°pidas por token
    conn.execute('CREATE INDEX IF NOT EXISTS idx_token ON verification_tokens(token)')
    
    conn.commit()
    conn.close()
    print("Tabela 'verification_tokens' verificada/criada.")


# ============================================================
# PASSO 2: Fun√ß√µes auxiliares para tokens
# ============================================================

def parse_datetime(dt_value):
    """Converte string para datetime se necess√°rio"""
    if dt_value is None:
        return None
    if isinstance(dt_value, datetime):
        return dt_value
    if isinstance(dt_value, str):
        # Tentar diferentes formatos
        for fmt in ['%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M:%S', '%Y-%m-%dT%H:%M:%S.%f', '%Y-%m-%dT%H:%M:%S']:
            try:
                return datetime.strptime(dt_value, fmt)
            except ValueError:
                continue
    return None


def generate_verification_token(player_id, validity_minutes=10):
    """
    Gera um token de verifica√ß√£o tempor√°rio para a carteirinha.
    
    Args:
        player_id: ID do jogador
        validity_minutes: Minutos de validade do token (padr√£o: 10)
    
    Returns:
        dict com token e data de expira√ß√£o (datetime)
    """
    conn = get_db_connection()
    
    # Limpar tokens expirados do jogador
    conn.execute('''
        DELETE FROM verification_tokens 
        WHERE player_id = ? AND expires_at < ?
    ''', (player_id, datetime.now()))
    
    # Verificar se j√° existe um token v√°lido
    existing = conn.execute('''
        SELECT token, expires_at FROM verification_tokens 
        WHERE player_id = ? AND expires_at > ? AND used_at IS NULL
        ORDER BY expires_at DESC LIMIT 1
    ''', (player_id, datetime.now())).fetchone()
    
    if existing:
        conn.close()
        expires = parse_datetime(existing['expires_at'])
        if expires is None:
            expires = datetime.now() + timedelta(minutes=validity_minutes)
        return {
            'token': existing['token'],
            'expires_at': expires
        }
    
    # Gerar novo token
    token = secrets.token_urlsafe(32)
    expires_at = datetime.now() + timedelta(minutes=validity_minutes)
    
    conn.execute('''
        INSERT INTO verification_tokens (player_id, token, expires_at)
        VALUES (?, ?, ?)
    ''', (player_id, token, expires_at))
    
    conn.commit()
    conn.close()
    
    return {
        'token': token,
        'expires_at': expires_at
    }


def validate_verification_token(token):
    """
    Valida um token de verifica√ß√£o.
    
    Args:
        token: Token a ser validado
    
    Returns:
        dict com dados do jogador se v√°lido, None se inv√°lido
    """
    conn = get_db_connection()
    
    result = conn.execute('''
        SELECT vt.*, 
               p.id as player_id, 
               p.name, 
               p.player_code,
               p.position, 
               p.tier, 
               p.handicap, 
               p.country, 
               p.profile_photo, 
               p.active, 
               p.created_at as member_since
        FROM verification_tokens vt
        JOIN players p ON vt.player_id = p.id
        WHERE vt.token = ? AND vt.expires_at > ?
    ''', (token, datetime.now())).fetchone()
    
    conn.close()
    
    if result:
        return dict(result)
    return None


def invalidate_token(token):
    """Marca um token como usado"""
    conn = get_db_connection()
    conn.execute('''
        UPDATE verification_tokens 
        SET used_at = ? 
        WHERE token = ?
    ''', (datetime.now(), token))
    conn.commit()
    conn.close()


# ============================================================
# PASSO 3: Rota da Carteirinha (para o jogador)
# ============================================================

@app.route('/carteirinha')
@login_required
def carteirinha():
    """Exibe a carteirinha digital do jogador logado"""
    user_id = session.get('user_id')
    
    if not user_id:
        flash('Voc√™ precisa estar logado para acessar sua carteirinha.', 'error')
        return redirect(url_for('login'))
    
    conn = get_db_connection()
    
    # Buscar dados do jogador
    player = conn.execute('''
        SELECT * FROM players WHERE id = ?
    ''', (user_id,)).fetchone()
    
    conn.close()
    
    if not player:
        flash('Jogador n√£o encontrado.', 'error')
        return redirect(url_for('dashboard'))
    
    if not player['active']:
        flash('Sua carteirinha est√° inativa. Entre em contato com a administra√ß√£o.', 'warning')
        return redirect(url_for('dashboard'))
    
    # Gerar token de verifica√ß√£o (v√°lido por 10 minutos)
    token_data = generate_verification_token(user_id, validity_minutes=10)
    
    # URL de verifica√ß√£o
    verification_url = url_for('verificar_carteirinha', token=token_data['token'], _external=True)
    
    # Garantir que expires_at √© um datetime
    expires_at = token_data['expires_at']
    if not isinstance(expires_at, datetime):
        expires_at = parse_datetime(expires_at)
    if expires_at is None:
        expires_at = datetime.now() + timedelta(minutes=10)
    
    return render_template('carteirinha.html', 
                          player=player,
                          token=token_data['token'],
                          expires_at=expires_at,
                          verification_url=verification_url)


@app.route('/carteirinha/renovar', methods=['POST'])
@login_required
def renovar_carteirinha():
    """Renova o token da carteirinha (gera um novo)"""
    user_id = session.get('user_id')
    
    if not user_id:
        return {'error': 'N√£o autorizado'}, 401
    
    conn = get_db_connection()
    
    # Invalidar tokens anteriores
    conn.execute('''
        DELETE FROM verification_tokens 
        WHERE player_id = ?
    ''', (user_id,))
    conn.commit()
    conn.close()
    
    # Gerar novo token
    token_data = generate_verification_token(user_id, validity_minutes=10)
    verification_url = url_for('verificar_carteirinha', token=token_data['token'], _external=True)
    
    # Garantir formato ISO para JSON
    expires_at = token_data['expires_at']
    if isinstance(expires_at, datetime):
        expires_at_str = expires_at.isoformat()
    else:
        expires_at_str = str(expires_at)
    
    return {
        'token': token_data['token'],
        'expires_at': expires_at_str,
        'verification_url': verification_url
    }


# ============================================================
# PASSO 4: Rota de Verifica√ß√£o (para o estabelecimento)
# ============================================================

@app.route('/verificar/<token>')
def verificar_carteirinha(token):
    """
    P√°gina p√∫blica para verifica√ß√£o da carteirinha.
    O estabelecimento escaneia o QR code e v√™ esta p√°gina.
    """
    verified_at = datetime.now()
    
    try:
        result = validate_verification_token(token)
    except Exception as e:
        print(f"Erro ao validar token: {e}")
        result = None
    
    if not result:
        return render_template('verificar_carteirinha.html', 
                              valid=False,
                              error='Token inv√°lido ou expirado',
                              verified_at=verified_at)
    
    # Calcular tempo restante
    try:
        expires_at = parse_datetime(result.get('expires_at'))
        if expires_at:
            time_remaining = expires_at - datetime.now()
            total_seconds = max(0, time_remaining.total_seconds())
            minutes_remaining = int(total_seconds // 60)
            seconds_remaining = int(total_seconds % 60)
        else:
            minutes_remaining = 0
            seconds_remaining = 0
    except Exception as e:
        print(f"Erro ao calcular tempo: {e}")
        minutes_remaining = 0
        seconds_remaining = 0
    
    return render_template('verificar_carteirinha.html',
                          valid=True,
                          player=result,
                          verified_at=verified_at,
                          minutes_remaining=minutes_remaining,
                          seconds_remaining=seconds_remaining)


# ============================================================
# PASSO 5: API para verifica√ß√£o (opcional - para apps)
# ============================================================

@app.route('/api/verificar/<token>')
def api_verificar_carteirinha(token):
    """API para verifica√ß√£o program√°tica da carteirinha"""
    result = validate_verification_token(token)
    
    if not result:
        return {
            'valid': False,
            'error': 'Token inv√°lido ou expirado'
        }, 404
    
    try:
        expires_at = parse_datetime(result.get('expires_at'))
        if expires_at:
            time_remaining = (expires_at - datetime.now()).total_seconds()
        else:
            time_remaining = 0
    except:
        time_remaining = 0
    
    return {
        'valid': True,
        'player': {
            'id': result.get('player_id'),
            'name': result.get('name'),
            'player_code': result.get('player_code'),
            'country': result.get('country'),
            'active': bool(result.get('active')),
            'profile_photo': result.get('profile_photo')
        },
        'verification': {
            'verified_at': datetime.now().isoformat(),
            'expires_at': expires_at.isoformat() if expires_at else None,
            'seconds_remaining': int(max(0, time_remaining))
        }
    }


# ============================================================
# PASSO 6: Limpeza de tokens expirados (opcional)
# ============================================================

def cleanup_expired_tokens():
    """Remove tokens expirados do banco de dados"""
    conn = get_db_connection()
    
    result = conn.execute('''
        DELETE FROM verification_tokens 
        WHERE expires_at < ?
    ''', (datetime.now(),))
    
    deleted_count = result.rowcount
    conn.commit()
    conn.close()
    
    if deleted_count > 0:
        print(f"üßπ {deleted_count} tokens expirados removidos.")
    
    return deleted_count


# ============================================================
# LEMBRETE: Adicionar no bloco if __name__ == '__main__':
# ============================================================
# 
# create_verification_tokens_table()
#