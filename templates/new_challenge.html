@app.route('/new_challenge', methods=['GET', 'POST'])
@login_required
def new_challenge():
    if request.method == 'POST':
        challenger_id = request.form['challenger_id']
        challenged_id = request.form['challenged_id']
        scheduled_date = request.form['scheduled_date']
        
        conn = get_db_connection()
        
        # Verificar se o desafio é válido conforme as regras
        # Verificar se ambos jogadores estão ativos
        challenger = conn.execute('SELECT * FROM players WHERE id = ? AND active = 1', (challenger_id,)).fetchone()
        challenged = conn.execute('SELECT * FROM players WHERE id = ? AND active = 1', (challenged_id,)).fetchone()
        
        if not challenger or not challenged:
            conn.close()
            flash('Um dos jogadores está inativo e não pode participar de desafios.', 'error')
            return redirect(url_for('new_challenge'))
        
        # NOVA REGRA: Verificar se algum dos jogadores já tem desafios pendentes ou aceitos
        pending_challenges = conn.execute('''
            SELECT * FROM challenges 
            WHERE (challenger_id = ? OR challenged_id = ? OR challenger_id = ? OR challenged_id = ?)
            AND status IN ('pending', 'accepted')
        ''', (challenger_id, challenger_id, challenged_id, challenged_id)).fetchall()
        
        error = None
        
        # Se encontrou desafios pendentes ou aceitos
        if pending_challenges:
            # Verificar se o desafio pendente é entre estes mesmos jogadores
            same_players_challenge = False
            for challenge in pending_challenges:
                if ((challenge['challenger_id'] == int(challenger_id) and challenge['challenged_id'] == int(challenged_id)) or
                    (challenge['challenger_id'] == int(challenged_id) and challenge['challenged_id'] == int(challenger_id))):
                    same_players_challenge = True
                    break
            
            if same_players_challenge:
                error = "Já existe um desafio pendente ou aceito entre estes jogadores."
            else:
                error = "Um dos jogadores já está envolvido em um desafio pendente ou aceito. Conclua o desafio atual antes de criar um novo."
        
        # Regras existentes
        if not error:
            # Regra: Desafio apenas uma linha acima
            challenger_tier = challenger['tier']
            challenged_tier = challenged['tier']
            
            # Calcular a diferença de níveis (em termos de "distância alfabética")
            tier_difference = ord(challenger_tier) - ord(challenged_tier)
            
            # Se o tier_difference é negativo, o desafiado está abaixo do desafiante (erro)
            if tier_difference < 0:
                error = "Você só pode desafiar jogadores de níveis acima do seu."
            # Se o tier_difference > 1, o desafiado está mais que uma linha acima (erro)
            elif tier_difference > 1:
                error = "Você só pode desafiar jogadores até uma linha acima da sua."
            # Verificar se o desafiado tem posição melhor (menor numericamente)
            elif challenged['position'] > challenger['position']:
                error = "Você só pode desafiar jogadores em posições melhores que a sua."
        
        if error:
            conn.close()
            flash(error, 'error')
            return redirect(url_for('new_challenge'))
        
        # Obter a data e hora atual
        current_datetime = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        # Calcular a data limite de resposta (7 dias a partir da data atual)
        response_deadline = (datetime.now() + timedelta(days=7)).strftime('%Y-%m-%d %H:%M:%S')
        
        # Inserir o novo desafio com a data/hora de criação e prazo de resposta
        conn.execute('''
            INSERT INTO challenges (challenger_id, challenged_id, status, scheduled_date, created_at, response_deadline)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (challenger_id, challenged_id, 'pending', scheduled_date, current_datetime, response_deadline))
        
        conn.commit()
        conn.close()
        
        flash('Desafio criado com sucesso!', 'success')
        return redirect(url_for('challenges_calendar'))
        
    # Para requisições GET, mostrar formulário
    conn = get_db_connection()
    
    # MODIFICAÇÃO: Verificar se o usuário está logado e não é admin
    preselected_challenger_id = None
    if 'user_id' in session and not session.get('is_admin', False):
        # Se o usuário está logado e não é admin, usar seu ID como challenger_id pré-selecionado
        preselected_challenger_id = str(session['user_id'])
    else:
        # Verificar se há um challenger_id na query string (comportamento anterior)
        preselected_challenger_id = request.args.get('challenger_id', None)
    
    # Buscar jogadores com desafios pendentes ou aceitos
    players_with_challenges = set()
    pending_challenges = conn.execute('''
        SELECT challenger_id, challenged_id 
        FROM challenges 
        WHERE status IN ('pending', 'accepted')
    ''').fetchall()
    
    for challenge in pending_challenges:
        players_with_challenges.add(challenge['challenger_id'])
        players_with_challenges.add(challenge['challenged_id'])
    
    # Se temos um desafiante pré-selecionado, obter apenas os jogadores que podem ser desafiados
    if preselected_challenger_id:
        # Verificar se o desafiante já tem desafios pendentes
        if int(preselected_challenger_id) in players_with_challenges:
            conn.close()
            flash('Este jogador já está envolvido em um desafio pendente ou aceito.', 'warning')
            return redirect(url_for('challenges_calendar'))
        
        # Buscar informações do desafiante
        challenger = conn.execute('SELECT * FROM players WHERE id = ? AND active = 1', (preselected_challenger_id,)).fetchone()
        
        if challenger:
            # Buscar todos os jogadores para a lista de desafiantes
            all_players = conn.execute('SELECT * FROM players WHERE active = 1 ORDER BY position').fetchall()
            
            # Buscar apenas jogadores que podem ser desafiados (mesmo nível ou um nível acima)
            # e que tenham posição melhor que o desafiante
            # e que NÃO estejam envolvidos em desafios pendentes
            eligible_challenged = conn.execute('''
                SELECT * FROM players 
                WHERE active = 1
                AND position < ? 
                AND (tier = ? OR tier = ?)
                ORDER BY position
            ''', (challenger['position'], challenger['tier'], chr(ord(challenger['tier'])-1))).fetchall()
            
            # Filtrar os jogadores que já têm desafios pendentes
            eligible_challenged = [player for player in eligible_challenged 
                                  if player['id'] not in players_with_challenges]
            
            # Adicionar data atual formatada para o campo de data
            today_date = datetime.now().strftime('%Y-%m-%d')
            
            conn.close()
            return render_template('new_challenge.html', 
                                all_players=all_players,
                                eligible_challenged=eligible_challenged,
                                preselected_challenger=preselected_challenger_id,
                                challenger_info=challenger,
                                today_date=today_date)
    
    # Se não houver um desafiante pré-selecionado, mostrar todos os jogadores disponíveis
    # (sem desafios pendentes) para seleção como desafiante
    all_players = conn.execute('SELECT * FROM players WHERE active = 1 ORDER BY position').fetchall()
    
    # Filtrar jogadores sem desafios pendentes para a lista de desafiantes
    available_players = [player for player in all_players 
                        if player['id'] not in players_with_challenges]
    
    conn.close()
    
    # Adicionar data atual formatada para o campo de data
    today_date = datetime.now().strftime('%Y-%m-%d')
    
    return render_template('new_challenge.html', 
                         all_players=available_players, 
                         eligible_challenged=[],
                         preselected_challenger=preselected_challenger_id,
                         today_date=today_date)